-- -------------------------------------------------------------
-- 
-- File Name: hdlsrc\hdlcoder_dwt\alpha4_level_dwt_tb.vhd
-- Created: 2023-05-02 15:37:20
-- 
-- Generated by MATLAB 9.11 and HDL Coder 3.19
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 1
-- Target subsystem base rate: 1
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out_5      2
-- ce_out_4      4
-- ce_out_3      8
-- ce_out_2      16
-- ce_out_1      32
-- ce_out_0      64
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- A6                            ce_out_0      64
-- D6                            ce_out_0      64
-- D5                            ce_out_1      32
-- D4                            ce_out_2      16
-- D3                            ce_out_3      8
-- D2                            ce_out_4      4
-- D1                            ce_out_5      2
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: alpha4_level_dwt_tb
-- Source Path: 
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_textio.ALL;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
LIBRARY STD;
USE STD.textio.ALL;
LIBRARY work;
USE work.alpha4_level_dwt_pkg.ALL;
USE work.alpha4_level_dwt_tb_pkg.ALL;

ENTITY alpha4_level_dwt_tb IS
END alpha4_level_dwt_tb;


ARCHITECTURE rtl OF alpha4_level_dwt_tb IS

  -- Component Declarations
  COMPONENT alpha4_level_dwt
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          clk_enable                      :   IN    std_logic;
          signal_in                       :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En12
          enable                          :   IN    std_logic;
          ce_out_0                        :   OUT   std_logic;
          ce_out_1                        :   OUT   std_logic;
          ce_out_2                        :   OUT   std_logic;
          ce_out_3                        :   OUT   std_logic;
          ce_out_4                        :   OUT   std_logic;
          ce_out_5                        :   OUT   std_logic;
          A6                              :   OUT   std_logic_vector(31 DOWNTO 0);  -- sfix32_En12
          D6                              :   OUT   std_logic_vector(31 DOWNTO 0);  -- sfix32_En12
          D5                              :   OUT   std_logic_vector(31 DOWNTO 0);  -- sfix32_En12
          D4                              :   OUT   std_logic_vector(31 DOWNTO 0);  -- sfix32_En12
          D3                              :   OUT   std_logic_vector(31 DOWNTO 0);  -- sfix32_En12
          D2                              :   OUT   std_logic_vector(31 DOWNTO 0);  -- sfix32_En12
          D1                              :   OUT   std_logic_vector(31 DOWNTO 0)  -- sfix32_En12
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : alpha4_level_dwt
    USE ENTITY work.alpha4_level_dwt(rtl);

  -- Signals
  SIGNAL clk                              : std_logic;
  SIGNAL reset                            : std_logic;
  SIGNAL clk_enable                       : std_logic;
  SIGNAL rawData_enable                   : std_logic;
  SIGNAL D1_done                          : std_logic;  -- ufix1
  SIGNAL ce_out_5                         : std_logic;
  SIGNAL D1_done_enb                      : std_logic;  -- ufix1
  SIGNAL D1_addr                          : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL D1_active                        : std_logic;  -- ufix1
  SIGNAL D1_enb                           : std_logic;  -- ufix1
  SIGNAL D1_lastAddr                      : std_logic;  -- ufix1
  SIGNAL resetn                           : std_logic;
  SIGNAL check7_done                      : std_logic;  -- ufix1
  SIGNAL D2_done                          : std_logic;  -- ufix1
  SIGNAL ce_out_4                         : std_logic;
  SIGNAL D2_done_enb                      : std_logic;  -- ufix1
  SIGNAL D2_addr                          : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL D2_active                        : std_logic;  -- ufix1
  SIGNAL D2_enb                           : std_logic;  -- ufix1
  SIGNAL D2_lastAddr                      : std_logic;  -- ufix1
  SIGNAL check6_done                      : std_logic;  -- ufix1
  SIGNAL D3_done                          : std_logic;  -- ufix1
  SIGNAL ce_out_3                         : std_logic;
  SIGNAL D3_done_enb                      : std_logic;  -- ufix1
  SIGNAL D3_addr                          : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL D3_active                        : std_logic;  -- ufix1
  SIGNAL D3_enb                           : std_logic;  -- ufix1
  SIGNAL D3_lastAddr                      : std_logic;  -- ufix1
  SIGNAL check5_done                      : std_logic;  -- ufix1
  SIGNAL D4_done                          : std_logic;  -- ufix1
  SIGNAL ce_out_2                         : std_logic;
  SIGNAL D4_done_enb                      : std_logic;  -- ufix1
  SIGNAL D4_addr                          : unsigned(6 DOWNTO 0);  -- ufix7
  SIGNAL D4_active                        : std_logic;  -- ufix1
  SIGNAL D4_enb                           : std_logic;  -- ufix1
  SIGNAL D4_lastAddr                      : std_logic;  -- ufix1
  SIGNAL check4_done                      : std_logic;  -- ufix1
  SIGNAL D5_done                          : std_logic;  -- ufix1
  SIGNAL ce_out_1                         : std_logic;
  SIGNAL D5_done_enb                      : std_logic;  -- ufix1
  SIGNAL D5_addr                          : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL D5_active                        : std_logic;  -- ufix1
  SIGNAL D5_enb                           : std_logic;  -- ufix1
  SIGNAL D5_lastAddr                      : std_logic;  -- ufix1
  SIGNAL check3_done                      : std_logic;  -- ufix1
  SIGNAL D6_done                          : std_logic;  -- ufix1
  SIGNAL ce_out_0                         : std_logic;
  SIGNAL D6_done_enb                      : std_logic;  -- ufix1
  SIGNAL A6_addr                          : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL D6_lastAddr                      : std_logic;  -- ufix1
  SIGNAL check2_done                      : std_logic;  -- ufix1
  SIGNAL A6_done                          : std_logic;  -- ufix1
  SIGNAL A6_done_enb                      : std_logic;  -- ufix1
  SIGNAL A6_active                        : std_logic;  -- ufix1
  SIGNAL holdData_enable                  : std_logic;
  SIGNAL tb_enb_delay                     : std_logic;
  SIGNAL enable_offset                    : std_logic;
  SIGNAL enable_1                         : std_logic;
  SIGNAL Data_Type_Conversion_out1_addr   : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL Data_Type_Conversion_out1_active : std_logic;  -- ufix1
  SIGNAL Data_Type_Conversion_out1_enb    : std_logic;  -- ufix1
  SIGNAL Data_Type_Conversion_out1_addr_delay_1 : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL rawData_signal_in                : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL holdData_signal_in               : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL signal_in_offset                 : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL signal_in                        : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL signal_in_1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL snkDone                          : std_logic;
  SIGNAL snkDonen                         : std_logic;
  SIGNAL tb_enb                           : std_logic;
  SIGNAL notDone                          : std_logic;
  SIGNAL A6                               : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL D6                               : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL D5                               : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL D4                               : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL D3                               : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL D2                               : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL D1                               : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL A6_enb                           : std_logic;  -- ufix1
  SIGNAL A6_lastAddr                      : std_logic;  -- ufix1
  SIGNAL check1_done                      : std_logic;  -- ufix1
  SIGNAL A6_signed                        : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL A6_addr_delay_1                  : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL A6_expected                      : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL A6_ref_hold                      : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL A6_ref                           : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL A6_testFailure                   : std_logic;  -- ufix1
  SIGNAL D6_signed                        : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL D6_addr_delay_1                  : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL D6_expected                      : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL D6_ref_hold                      : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL D6_ref                           : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL D6_testFailure                   : std_logic;  -- ufix1
  SIGNAL D5_signed                        : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL D5_addr_delay_1                  : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL D5_expected                      : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL D5_ref_hold                      : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL D5_ref                           : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL D5_testFailure                   : std_logic;  -- ufix1
  SIGNAL D4_signed                        : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL D4_addr_delay_1                  : unsigned(6 DOWNTO 0);  -- ufix7
  SIGNAL D4_expected                      : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL D4_ref_hold                      : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL D4_ref                           : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL D4_testFailure                   : std_logic;  -- ufix1
  SIGNAL D3_signed                        : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL D3_addr_delay_1                  : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL D3_expected                      : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL D3_ref_hold                      : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL D3_ref                           : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL D3_testFailure                   : std_logic;  -- ufix1
  SIGNAL D2_signed                        : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL D2_addr_delay_1                  : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL D2_expected                      : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL D2_ref_hold                      : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL D2_ref                           : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL D2_testFailure                   : std_logic;  -- ufix1
  SIGNAL D1_signed                        : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL D1_addr_delay_1                  : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL D1_expected                      : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL D1_ref_hold                      : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL D1_ref                           : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL D1_testFailure                   : std_logic;  -- ufix1
  SIGNAL testFailure                      : std_logic;  -- ufix1

BEGIN
  u_alpha4_level_dwt : alpha4_level_dwt
    PORT MAP( clk => clk,
              reset => reset,
              clk_enable => clk_enable,
              signal_in => signal_in_1,  -- sfix32_En12
              enable => enable_1,
              ce_out_0 => ce_out_0,
              ce_out_1 => ce_out_1,
              ce_out_2 => ce_out_2,
              ce_out_3 => ce_out_3,
              ce_out_4 => ce_out_4,
              ce_out_5 => ce_out_5,
              A6 => A6,  -- sfix32_En12
              D6 => D6,  -- sfix32_En12
              D5 => D5,  -- sfix32_En12
              D4 => D4,  -- sfix32_En12
              D3 => D3,  -- sfix32_En12
              D2 => D2,  -- sfix32_En12
              D1 => D1  -- sfix32_En12
              );

  -- Data source for enable
  rawData_enable <= '1';

  D1_done_enb <= D1_done AND ce_out_5;

  
  D1_active <= '1' WHEN D1_addr /= to_unsigned(16#226#, 10) ELSE
      '0';

  D1_enb <= ce_out_5 AND D1_active;

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 550
  c_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      D1_addr <= to_unsigned(16#000#, 10);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF D1_enb = '1' THEN
        IF D1_addr >= to_unsigned(16#226#, 10) THEN 
          D1_addr <= to_unsigned(16#000#, 10);
        ELSE 
          D1_addr <= D1_addr + to_unsigned(16#001#, 10);
        END IF;
      END IF;
    END IF;
  END PROCESS c_1_process;


  
  D1_lastAddr <= '1' WHEN D1_addr >= to_unsigned(16#226#, 10) ELSE
      '0';

  D1_done <= D1_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_7_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check7_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF D1_done_enb = '1' THEN
        check7_done <= D1_done;
      END IF;
    END IF;
  END PROCESS checkDone_7_process;

  D2_done_enb <= D2_done AND ce_out_4;

  
  D2_active <= '1' WHEN D2_addr /= to_unsigned(16#113#, 9) ELSE
      '0';

  D2_enb <= ce_out_4 AND D2_active;

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 275
  c_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      D2_addr <= to_unsigned(16#000#, 9);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF D2_enb = '1' THEN
        IF D2_addr >= to_unsigned(16#113#, 9) THEN 
          D2_addr <= to_unsigned(16#000#, 9);
        ELSE 
          D2_addr <= D2_addr + to_unsigned(16#001#, 9);
        END IF;
      END IF;
    END IF;
  END PROCESS c_2_process;


  
  D2_lastAddr <= '1' WHEN D2_addr >= to_unsigned(16#113#, 9) ELSE
      '0';

  D2_done <= D2_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_6_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check6_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF D2_done_enb = '1' THEN
        check6_done <= D2_done;
      END IF;
    END IF;
  END PROCESS checkDone_6_process;

  D3_done_enb <= D3_done AND ce_out_3;

  
  D3_active <= '1' WHEN D3_addr /= to_unsigned(16#89#, 8) ELSE
      '0';

  D3_enb <= ce_out_3 AND D3_active;

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 137
  c_3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      D3_addr <= to_unsigned(16#00#, 8);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF D3_enb = '1' THEN
        IF D3_addr >= to_unsigned(16#89#, 8) THEN 
          D3_addr <= to_unsigned(16#00#, 8);
        ELSE 
          D3_addr <= D3_addr + to_unsigned(16#01#, 8);
        END IF;
      END IF;
    END IF;
  END PROCESS c_3_process;


  
  D3_lastAddr <= '1' WHEN D3_addr >= to_unsigned(16#89#, 8) ELSE
      '0';

  D3_done <= D3_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_5_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check5_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF D3_done_enb = '1' THEN
        check5_done <= D3_done;
      END IF;
    END IF;
  END PROCESS checkDone_5_process;

  D4_done_enb <= D4_done AND ce_out_2;

  
  D4_active <= '1' WHEN D4_addr /= to_unsigned(16#44#, 7) ELSE
      '0';

  D4_enb <= ce_out_2 AND D4_active;

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 68
  c_4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      D4_addr <= to_unsigned(16#00#, 7);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF D4_enb = '1' THEN
        IF D4_addr >= to_unsigned(16#44#, 7) THEN 
          D4_addr <= to_unsigned(16#00#, 7);
        ELSE 
          D4_addr <= D4_addr + to_unsigned(16#01#, 7);
        END IF;
      END IF;
    END IF;
  END PROCESS c_4_process;


  
  D4_lastAddr <= '1' WHEN D4_addr >= to_unsigned(16#44#, 7) ELSE
      '0';

  D4_done <= D4_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_4_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check4_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF D4_done_enb = '1' THEN
        check4_done <= D4_done;
      END IF;
    END IF;
  END PROCESS checkDone_4_process;

  D5_done_enb <= D5_done AND ce_out_1;

  
  D5_active <= '1' WHEN D5_addr /= to_unsigned(16#22#, 6) ELSE
      '0';

  D5_enb <= ce_out_1 AND D5_active;

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 34
  c_5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      D5_addr <= to_unsigned(16#00#, 6);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF D5_enb = '1' THEN
        IF D5_addr >= to_unsigned(16#22#, 6) THEN 
          D5_addr <= to_unsigned(16#00#, 6);
        ELSE 
          D5_addr <= D5_addr + to_unsigned(16#01#, 6);
        END IF;
      END IF;
    END IF;
  END PROCESS c_5_process;


  
  D5_lastAddr <= '1' WHEN D5_addr >= to_unsigned(16#22#, 6) ELSE
      '0';

  D5_done <= D5_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_3_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check3_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF D5_done_enb = '1' THEN
        check3_done <= D5_done;
      END IF;
    END IF;
  END PROCESS checkDone_3_process;

  D6_done_enb <= D6_done AND ce_out_0;

  
  D6_lastAddr <= '1' WHEN A6_addr >= to_unsigned(16#11#, 5) ELSE
      '0';

  D6_done <= D6_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_2_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check2_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF D6_done_enb = '1' THEN
        check2_done <= D6_done;
      END IF;
    END IF;
  END PROCESS checkDone_2_process;

  A6_done_enb <= A6_done AND ce_out_0;

  
  A6_active <= '1' WHEN A6_addr /= to_unsigned(16#11#, 5) ELSE
      '0';

  -- holdData reg for Constant1_out1
  stimuli_Constant1_out1_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_enable <= 'X';
    ELSIF clk'event AND clk = '1' THEN
      holdData_enable <= rawData_enable;
    END IF;
  END PROCESS stimuli_Constant1_out1_process;

  stimuli_Constant1_out1_1: PROCESS (rawData_enable, tb_enb_delay)
  BEGIN
    IF tb_enb_delay = '0' THEN
      enable_offset <= holdData_enable;
    ELSE
      enable_offset <= rawData_enable;
    END IF;
  END PROCESS stimuli_Constant1_out1_1;

  enable_1 <= enable_offset AFTER 2 ns;

  
  Data_Type_Conversion_out1_active <= '1' WHEN Data_Type_Conversion_out1_addr /= to_unsigned(16#44C#, 11) ELSE
      '0';

  Data_Type_Conversion_out1_enb <= Data_Type_Conversion_out1_active AND (tb_enb_delay AND tb_enb_delay);

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 1100
  DataTypeConversion_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Data_Type_Conversion_out1_addr <= to_unsigned(16#000#, 11);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF Data_Type_Conversion_out1_enb = '1' THEN
        IF Data_Type_Conversion_out1_addr >= to_unsigned(16#44C#, 11) THEN 
          Data_Type_Conversion_out1_addr <= to_unsigned(16#000#, 11);
        ELSE 
          Data_Type_Conversion_out1_addr <= Data_Type_Conversion_out1_addr + to_unsigned(16#001#, 11);
        END IF;
      END IF;
    END IF;
  END PROCESS DataTypeConversion_process;


  Data_Type_Conversion_out1_addr_delay_1 <= Data_Type_Conversion_out1_addr AFTER 1 ns;

  -- Data source for signal_in
  signal_in_fileread: PROCESS (Data_Type_Conversion_out1_addr_delay_1, tb_enb_delay)
    FILE fp: TEXT open READ_MODE is "signal_in.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb_delay /= '1' THEN
    ELSIF tb_enb_delay = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_signal_in <= signed(read_data(31 DOWNTO 0));
  END PROCESS signal_in_fileread;

  -- holdData reg for Data_Type_Conversion_out1
  stimuli_Data_Type_Conversion_out1_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_signal_in <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_signal_in <= rawData_signal_in;
    END IF;
  END PROCESS stimuli_Data_Type_Conversion_out1_process;

  stimuli_Data_Type_Conversion_out1_1: PROCESS (rawData_signal_in, tb_enb_delay)
  BEGIN
    IF tb_enb_delay = '0' THEN
      signal_in_offset <= holdData_signal_in;
    ELSE
      signal_in_offset <= rawData_signal_in;
    END IF;
  END PROCESS stimuli_Data_Type_Conversion_out1_1;

  signal_in <= signal_in_offset AFTER 2 ns;

  signal_in_1 <= std_logic_vector(signal_in);

  snkDonen <=  NOT snkDone;

  resetn <=  NOT reset;

  tb_enb <= resetn AND snkDonen;

  -- Delay inside enable generation: register depth 1
  u_enable_delay_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      tb_enb_delay <= '0';
    ELSIF clk'event AND clk = '1' THEN
      tb_enb_delay <= tb_enb;
    END IF;
  END PROCESS u_enable_delay_process;

  notDone <= tb_enb_delay AND snkDonen;

  clk_enable <= notDone AFTER 2 ns;

  reset_gen: PROCESS 
  BEGIN
    reset <= '1';
    WAIT FOR 20 ns;
    WAIT UNTIL clk'event AND clk = '1';
    WAIT FOR 2 ns;
    reset <= '0';
    WAIT;
  END PROCESS reset_gen;

  clk_gen: PROCESS 
  BEGIN
    clk <= '1';
    WAIT FOR 5 ns;
    clk <= '0';
    WAIT FOR 5 ns;
    IF snkDone = '1' THEN
      clk <= '1';
      WAIT FOR 5 ns;
      clk <= '0';
      WAIT FOR 5 ns;
      WAIT;
    END IF;
  END PROCESS clk_gen;

  A6_enb <= ce_out_0 AND A6_active;

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 17
  c_8_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      A6_addr <= to_unsigned(16#00#, 5);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF A6_enb = '1' THEN
        IF A6_addr >= to_unsigned(16#11#, 5) THEN 
          A6_addr <= to_unsigned(16#00#, 5);
        ELSE 
          A6_addr <= A6_addr + to_unsigned(16#01#, 5);
        END IF;
      END IF;
    END IF;
  END PROCESS c_8_process;


  
  A6_lastAddr <= '1' WHEN A6_addr >= to_unsigned(16#11#, 5) ELSE
      '0';

  A6_done <= A6_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_1_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check1_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF A6_done_enb = '1' THEN
        check1_done <= A6_done;
      END IF;
    END IF;
  END PROCESS checkDone_1_process;

  snkDone <= check7_done AND (check6_done AND (check5_done AND (check4_done AND (check3_done AND (check1_done AND check2_done)))));

  A6_signed <= signed(A6);

  A6_addr_delay_1 <= A6_addr AFTER 1 ns;

  -- Data source for A6_expected
  A6_expected_fileread: PROCESS (A6_addr_delay_1, tb_enb_delay)
    FILE fp: TEXT open READ_MODE is "A6_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb_delay /= '1' THEN
    ELSIF NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    A6_expected <= signed(read_data(31 DOWNTO 0));
  END PROCESS A6_expected_fileread;

  -- Bypass register to hold A6_ref
  DataHold_A6_ref_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      A6_ref_hold <= (OTHERS => '0');
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out_0 = '1' THEN
        A6_ref_hold <= A6_expected;
      END IF;
    END IF;
  END PROCESS DataHold_A6_ref_process;

  
  A6_ref <= A6_ref_hold WHEN ce_out_0 = '0' ELSE
      A6_expected;

  A6_signed_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      A6_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out_0 = '1' AND A6_signed /= A6_ref THEN
        A6_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in A6_signed: Expected " & to_hex(A6_ref) & (" Actual " & to_hex(A6_signed))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS A6_signed_checker;

  D6_signed <= signed(D6);

  D6_addr_delay_1 <= A6_addr AFTER 1 ns;

  -- Data source for D6_expected
  D6_expected_fileread: PROCESS (D6_addr_delay_1, tb_enb_delay)
    FILE fp: TEXT open READ_MODE is "D6_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb_delay /= '1' THEN
    ELSIF NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    D6_expected <= signed(read_data(31 DOWNTO 0));
  END PROCESS D6_expected_fileread;

  -- Bypass register to hold D6_ref
  DataHold_D6_ref_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      D6_ref_hold <= (OTHERS => '0');
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out_0 = '1' THEN
        D6_ref_hold <= D6_expected;
      END IF;
    END IF;
  END PROCESS DataHold_D6_ref_process;

  
  D6_ref <= D6_ref_hold WHEN ce_out_0 = '0' ELSE
      D6_expected;

  D6_signed_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      D6_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out_0 = '1' AND D6_signed /= D6_ref THEN
        D6_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in D6_signed: Expected " & to_hex(D6_ref) & (" Actual " & to_hex(D6_signed))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS D6_signed_checker;

  D5_signed <= signed(D5);

  D5_addr_delay_1 <= D5_addr AFTER 1 ns;

  -- Data source for D5_expected
  D5_expected_fileread: PROCESS (D5_addr_delay_1, tb_enb_delay)
    FILE fp: TEXT open READ_MODE is "D5_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb_delay /= '1' THEN
    ELSIF NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    D5_expected <= signed(read_data(31 DOWNTO 0));
  END PROCESS D5_expected_fileread;

  -- Bypass register to hold D5_ref
  DataHold_D5_ref_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      D5_ref_hold <= (OTHERS => '0');
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out_1 = '1' THEN
        D5_ref_hold <= D5_expected;
      END IF;
    END IF;
  END PROCESS DataHold_D5_ref_process;

  
  D5_ref <= D5_ref_hold WHEN ce_out_1 = '0' ELSE
      D5_expected;

  D5_signed_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      D5_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out_1 = '1' AND D5_signed /= D5_ref THEN
        D5_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in D5_signed: Expected " & to_hex(D5_ref) & (" Actual " & to_hex(D5_signed))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS D5_signed_checker;

  D4_signed <= signed(D4);

  D4_addr_delay_1 <= D4_addr AFTER 1 ns;

  -- Data source for D4_expected
  D4_expected_fileread: PROCESS (D4_addr_delay_1, tb_enb_delay)
    FILE fp: TEXT open READ_MODE is "D4_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb_delay /= '1' THEN
    ELSIF NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    D4_expected <= signed(read_data(31 DOWNTO 0));
  END PROCESS D4_expected_fileread;

  -- Bypass register to hold D4_ref
  DataHold_D4_ref_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      D4_ref_hold <= (OTHERS => '0');
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out_2 = '1' THEN
        D4_ref_hold <= D4_expected;
      END IF;
    END IF;
  END PROCESS DataHold_D4_ref_process;

  
  D4_ref <= D4_ref_hold WHEN ce_out_2 = '0' ELSE
      D4_expected;

  D4_signed_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      D4_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out_2 = '1' AND D4_signed /= D4_ref THEN
        D4_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in D4_signed: Expected " & to_hex(D4_ref) & (" Actual " & to_hex(D4_signed))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS D4_signed_checker;

  D3_signed <= signed(D3);

  D3_addr_delay_1 <= D3_addr AFTER 1 ns;

  -- Data source for D3_expected
  D3_expected_fileread: PROCESS (D3_addr_delay_1, tb_enb_delay)
    FILE fp: TEXT open READ_MODE is "D3_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb_delay /= '1' THEN
    ELSIF NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    D3_expected <= signed(read_data(31 DOWNTO 0));
  END PROCESS D3_expected_fileread;

  -- Bypass register to hold D3_ref
  DataHold_D3_ref_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      D3_ref_hold <= (OTHERS => '0');
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out_3 = '1' THEN
        D3_ref_hold <= D3_expected;
      END IF;
    END IF;
  END PROCESS DataHold_D3_ref_process;

  
  D3_ref <= D3_ref_hold WHEN ce_out_3 = '0' ELSE
      D3_expected;

  D3_signed_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      D3_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out_3 = '1' AND D3_signed /= D3_ref THEN
        D3_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in D3_signed: Expected " & to_hex(D3_ref) & (" Actual " & to_hex(D3_signed))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS D3_signed_checker;

  D2_signed <= signed(D2);

  D2_addr_delay_1 <= D2_addr AFTER 1 ns;

  -- Data source for D2_expected
  D2_expected_fileread: PROCESS (D2_addr_delay_1, tb_enb_delay)
    FILE fp: TEXT open READ_MODE is "D2_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb_delay /= '1' THEN
    ELSIF NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    D2_expected <= signed(read_data(31 DOWNTO 0));
  END PROCESS D2_expected_fileread;

  -- Bypass register to hold D2_ref
  DataHold_D2_ref_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      D2_ref_hold <= (OTHERS => '0');
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out_4 = '1' THEN
        D2_ref_hold <= D2_expected;
      END IF;
    END IF;
  END PROCESS DataHold_D2_ref_process;

  
  D2_ref <= D2_ref_hold WHEN ce_out_4 = '0' ELSE
      D2_expected;

  D2_signed_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      D2_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out_4 = '1' AND D2_signed /= D2_ref THEN
        D2_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in D2_signed: Expected " & to_hex(D2_ref) & (" Actual " & to_hex(D2_signed))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS D2_signed_checker;

  D1_signed <= signed(D1);

  D1_addr_delay_1 <= D1_addr AFTER 1 ns;

  -- Data source for D1_expected
  D1_expected_fileread: PROCESS (D1_addr_delay_1, tb_enb_delay)
    FILE fp: TEXT open READ_MODE is "D1_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb_delay /= '1' THEN
    ELSIF NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    D1_expected <= signed(read_data(31 DOWNTO 0));
  END PROCESS D1_expected_fileread;

  -- Bypass register to hold D1_ref
  DataHold_D1_ref_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      D1_ref_hold <= (OTHERS => '0');
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out_5 = '1' THEN
        D1_ref_hold <= D1_expected;
      END IF;
    END IF;
  END PROCESS DataHold_D1_ref_process;

  
  D1_ref <= D1_ref_hold WHEN ce_out_5 = '0' ELSE
      D1_expected;

  D1_signed_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      D1_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out_5 = '1' AND D1_signed /= D1_ref THEN
        D1_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in D1_signed: Expected " & to_hex(D1_ref) & (" Actual " & to_hex(D1_signed))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS D1_signed_checker;

  testFailure <= D1_testFailure OR (D2_testFailure OR (D3_testFailure OR (D4_testFailure OR (D5_testFailure OR (A6_testFailure OR D6_testFailure)))));

  completed_msg: PROCESS (clk)
  BEGIN
    IF clk'event AND clk = '1' THEN
      IF snkDone = '1' THEN
        IF testFailure = '0' THEN
          ASSERT FALSE
            REPORT "**************TEST COMPLETED (PASSED)**************"
            SEVERITY NOTE;
        ELSE
          ASSERT FALSE
            REPORT "**************TEST COMPLETED (FAILED)**************"
            SEVERITY NOTE;
        END IF;
      END IF;
    END IF;
  END PROCESS completed_msg;

END rtl;

