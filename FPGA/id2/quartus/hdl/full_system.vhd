-- -------------------------------------------------------------
-- 
-- File Name: hdlsrc\full_system_nios_id2\full_system.vhd
-- Created: 2023-05-25 08:56:44
-- 
-- Generated by MATLAB 9.11 and HDL Coder 3.19
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 1
-- Target subsystem base rate: 1
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        1
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- svm_out                       ce_out        1
-- done                          ce_out        1
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: full_system
-- Source Path: full_system_nios_id2/full_system
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.full_system_pkg.ALL;

ENTITY full_system IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        signal_in                         :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En4
        enable                            :   IN    std_logic;
        scale                             :   IN    std_logic_vector(41 DOWNTO 0);  -- sfix42_En12
        s_ene_mu                          :   IN    std_logic_vector(41 DOWNTO 0);  -- sfix42_En12
        s_ene_sig                         :   IN    std_logic_vector(41 DOWNTO 0);  -- sfix42_En12
        s_ene_beta                        :   IN    std_logic_vector(41 DOWNTO 0);  -- sfix42_En12
        ene_mu_D2                         :   IN    std_logic_vector(41 DOWNTO 0);  -- sfix42_En12
        ene_sig_D2                        :   IN    std_logic_vector(41 DOWNTO 0);  -- sfix42_En12
        ene_beta_D2                       :   IN    std_logic_vector(41 DOWNTO 0);  -- sfix42_En12
        bias                              :   IN    std_logic_vector(41 DOWNTO 0);  -- sfix42_En12
        ce_out                            :   OUT   std_logic;
        svm_out                           :   OUT   std_logic_vector(42 DOWNTO 0);  -- sfix43_En12
        done                              :   OUT   std_logic
        );
END full_system;


ARCHITECTURE rtl OF full_system IS

  ATTRIBUTE multstyle : string;

  -- Component Declarations
  COMPONENT full_system_tc
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          clk_enable                      :   IN    std_logic;
          enb                             :   OUT   std_logic;
          enb_1_1_1                       :   OUT   std_logic;
          enb_1_2_0                       :   OUT   std_logic;
          enb_1_2_1                       :   OUT   std_logic;
          enb_1_4_0                       :   OUT   std_logic;
          enb_1_4_1                       :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT Discrete_FIR_Filter3
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          Discrete_FIR_Filter3_in         :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En4
          Discrete_FIR_Filter3_coeff      :   IN    vector_of_std_logic_vector16(0 TO 7);  -- int16 [8]
          Discrete_FIR_Filter3_out        :   OUT   std_logic_vector(34 DOWNTO 0)  -- sfix35_En4
          );
  END COMPONENT;

  COMPONENT Discrete_FIR_Filter
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_2_0                       :   IN    std_logic;
          Discrete_FIR_Filter_in          :   IN    std_logic_vector(34 DOWNTO 0);  -- sfix35_En4
          Discrete_FIR_Filter_coeff       :   IN    vector_of_std_logic_vector16(0 TO 7);  -- int16 [8]
          Discrete_FIR_Filter_out         :   OUT   std_logic_vector(53 DOWNTO 0)  -- sfix54_En4
          );
  END COMPONENT;

  COMPONENT predictor
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          variable_rsvd                   :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En8
          trigger                         :   IN    std_logic;
          mu                              :   IN    std_logic_vector(41 DOWNTO 0);  -- sfix42_En12
          sigma                           :   IN    std_logic_vector(41 DOWNTO 0);  -- sfix42_En12
          scale                           :   IN    std_logic_vector(41 DOWNTO 0);  -- sfix42_En12
          beta                            :   IN    std_logic_vector(41 DOWNTO 0);  -- sfix42_En12
          predicted                       :   OUT   std_logic_vector(31 DOWNTO 0)  -- sfix32_En12
          );
  END COMPONENT;

  COMPONENT predictor10
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          variable_rsvd                   :   IN    std_logic_vector(37 DOWNTO 0);  -- sfix38_En8
          trigger                         :   IN    std_logic;
          mu                              :   IN    std_logic_vector(41 DOWNTO 0);  -- sfix42_En12
          sigma                           :   IN    std_logic_vector(41 DOWNTO 0);  -- sfix42_En12
          scale                           :   IN    std_logic_vector(41 DOWNTO 0);  -- sfix42_En12
          beta                            :   IN    std_logic_vector(41 DOWNTO 0);  -- sfix42_En12
          predicted                       :   OUT   std_logic_vector(31 DOWNTO 0)  -- sfix32_En12
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : full_system_tc
    USE ENTITY work.full_system_tc(rtl);

  FOR ALL : Discrete_FIR_Filter3
    USE ENTITY work.Discrete_FIR_Filter3(rtl);

  FOR ALL : Discrete_FIR_Filter
    USE ENTITY work.Discrete_FIR_Filter(rtl);

  FOR ALL : predictor
    USE ENTITY work.predictor(rtl);

  FOR ALL : predictor10
    USE ENTITY work.predictor10(rtl);

  -- Signals
  SIGNAL enb                              : std_logic;
  SIGNAL enb_1_2_0                        : std_logic;
  SIGNAL enb_1_4_0                        : std_logic;
  SIGNAL enb_1_2_1                        : std_logic;
  SIGNAL enb_1_4_1                        : std_logic;
  SIGNAL enb_1_1_1                        : std_logic;
  SIGNAL bias_signed                      : signed(41 DOWNTO 0);  -- sfix42_En12
  SIGNAL Constant7_out1                   : std_logic;
  SIGNAL NOT_out1                         : std_logic;
  SIGNAL HDL_Counter_out1                 : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL Constant4_out1                   : std_logic;
  SIGNAL trigger                          : std_logic;
  SIGNAL trigger_1                        : std_logic;
  SIGNAL Delay2_reg                       : std_logic_vector(0 TO 448);  -- ufix1 [449]
  SIGNAL trigger_2                        : std_logic;
  SIGNAL trigger_bool                     : std_logic;
  SIGNAL trigger_delay                    : std_logic;
  SIGNAL trigger_delayN                   : std_logic;
  SIGNAL trigger_rEdge                    : std_logic;
  SIGNAL Discrete_Time_Integrator2_reg_iv : signed(31 DOWNTO 0);  -- sfix32_En8
  SIGNAL signal_in_signed                 : signed(15 DOWNTO 0);  -- sfix16_En4
  SIGNAL Delay_reg                        : vector_of_signed16(0 TO 447);  -- sfix16 [448]
  SIGNAL signal_rsvd                      : signed(15 DOWNTO 0);  -- sfix16_En4
  SIGNAL Product1_out1                    : signed(31 DOWNTO 0);  -- sfix32_En8
  SIGNAL Product1_out1_dlyBalance         : signed(31 DOWNTO 0);  -- sfix32_En8
  SIGNAL Discrete_Time_Integrator2_u_add  : signed(31 DOWNTO 0);  -- sfix32_En8
  SIGNAL Discrete_Time_Integrator2_reg_toDel : signed(31 DOWNTO 0);  -- sfix32_En8
  SIGNAL Discrete_Time_Integrator2_x_reg_out : signed(31 DOWNTO 0);  -- sfix32_En8
  SIGNAL Constant3_out1                   : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL energy                           : signed(31 DOWNTO 0);  -- sfix32_En8
  SIGNAL Delay3_out1                      : signed(31 DOWNTO 0);  -- sfix32_En8
  SIGNAL trigger_bool_1                   : std_logic;
  SIGNAL trigger_delay_1                  : std_logic;
  SIGNAL trigger_delayN_1                 : std_logic;
  SIGNAL trigger_rEdge_1                  : std_logic;
  SIGNAL Discrete_Time_Integrator1_reg_iv : signed(37 DOWNTO 0);  -- sfix38_En8
  SIGNAL RT2_bypass_reg                   : std_logic;  -- ufix1
  SIGNAL RT2_out1                         : std_logic;
  SIGNAL switch_compare_1                 : std_logic;
  SIGNAL Constant_out1                    : signed(53 DOWNTO 0);  -- sfix54_En4
  SIGNAL RT1_bypass_reg                   : std_logic;  -- ufix1
  SIGNAL RT1_out1                         : std_logic;
  SIGNAL switch_compare_1_1               : std_logic;
  SIGNAL Constant1_out1                   : signed(34 DOWNTO 0);  -- sfix35_En4
  SIGNAL db4_scaling1_out1                : vector_of_signed16(0 TO 7);  -- int16 [8]
  SIGNAL db4_scaling1_out1_1              : vector_of_std_logic_vector16(0 TO 7);  -- ufix16 [8]
  SIGNAL Discrete_FIR_Filter3_out1        : std_logic_vector(34 DOWNTO 0);  -- ufix35
  SIGNAL Discrete_FIR_Filter3_out1_signed : signed(34 DOWNTO 0);  -- sfix35_En4
  SIGNAL Downsample3_out1                 : signed(34 DOWNTO 0);  -- sfix35_En4
  SIGNAL Switch3_out1                     : signed(34 DOWNTO 0);  -- sfix35_En4
  SIGNAL db4_wavelet_out1                 : vector_of_signed16(0 TO 7);  -- int16 [8]
  SIGNAL db4_wavelet_out1_1               : vector_of_std_logic_vector16(0 TO 7);  -- ufix16 [8]
  SIGNAL Discrete_FIR_Filter_out1         : std_logic_vector(53 DOWNTO 0);  -- ufix54
  SIGNAL Discrete_FIR_Filter_out1_signed  : signed(53 DOWNTO 0);  -- sfix54_En4
  SIGNAL Downsample_out1                  : signed(53 DOWNTO 0);  -- sfix54_En4
  SIGNAL Switch_out1                      : signed(53 DOWNTO 0);  -- sfix54_En4
  SIGNAL delayMatch_reg                   : vector_of_signed54(0 TO 107);  -- sfix54 [108]
  SIGNAL Switch_out1_1                    : signed(53 DOWNTO 0);  -- sfix54_En4
  SIGNAL in_rsvd                          : signed(18 DOWNTO 0);  -- sfix19_En4
  SIGNAL in_rsvd_1                        : signed(18 DOWNTO 0);  -- sfix19_En4
  SIGNAL Product_out1                     : signed(37 DOWNTO 0);  -- sfix38_En8
  SIGNAL Product_out1_dlyBalance          : signed(37 DOWNTO 0);  -- sfix38_En8
  SIGNAL Discrete_Time_Integrator1_u_add  : signed(37 DOWNTO 0);  -- sfix38_En8
  SIGNAL Discrete_Time_Integrator1_reg_toDel : signed(37 DOWNTO 0);  -- sfix38_En8
  SIGNAL Discrete_Time_Integrator1_x_reg_out : signed(37 DOWNTO 0);  -- sfix38_En8
  SIGNAL Constant2_out1                   : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL energy_1                         : signed(37 DOWNTO 0);  -- sfix38_En8
  SIGNAL Delay5_out1                      : signed(37 DOWNTO 0);  -- sfix38_En8
  SIGNAL bias_1                           : signed(41 DOWNTO 0);  -- sfix42_En12
  SIGNAL after_beta                       : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL after_beta_signed                : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL Add_stage2_add_cast              : signed(42 DOWNTO 0);  -- sfix43_En12
  SIGNAL Add_stage2_add_cast_1            : signed(42 DOWNTO 0);  -- sfix43_En12
  SIGNAL Add_op_stage1                    : signed(42 DOWNTO 0);  -- sfix43_En12
  SIGNAL after_beta_1                     : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL after_beta_signed_1              : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL Add_stage3_add_cast              : signed(42 DOWNTO 0);  -- sfix43_En12
  SIGNAL predictor_1                      : signed(42 DOWNTO 0);  -- sfix43_En12
  SIGNAL HDL_Counter1_out1                : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL switch_compare_1_2               : std_logic;
  SIGNAL Constant5_out1                   : std_logic;
  SIGNAL Constant6_out1                   : std_logic;
  SIGNAL done_1                           : std_logic;

BEGIN
  -- features_extraction
  -- 
  -- 4_level_dwt
  -- 
  -- 1_level_dwt1
  -- 
  -- 1_level_dwt
  -- 
  -- compute_stats2
  -- 
  -- compute_stats

  u_full_system_tc : full_system_tc
    PORT MAP( clk => clk,
              reset => reset,
              clk_enable => clk_enable,
              enb => enb,
              enb_1_1_1 => enb_1_1_1,
              enb_1_2_0 => enb_1_2_0,
              enb_1_2_1 => enb_1_2_1,
              enb_1_4_0 => enb_1_4_0,
              enb_1_4_1 => enb_1_4_1
              );

  u_Discrete_FIR_Filter3 : Discrete_FIR_Filter3
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              Discrete_FIR_Filter3_in => signal_in,  -- sfix16_En4
              Discrete_FIR_Filter3_coeff => db4_scaling1_out1_1,  -- int16 [8]
              Discrete_FIR_Filter3_out => Discrete_FIR_Filter3_out1  -- sfix35_En4
              );

  u_Discrete_FIR_Filter : Discrete_FIR_Filter
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_2_0 => enb_1_2_0,
              Discrete_FIR_Filter_in => std_logic_vector(Switch3_out1),  -- sfix35_En4
              Discrete_FIR_Filter_coeff => db4_wavelet_out1_1,  -- int16 [8]
              Discrete_FIR_Filter_out => Discrete_FIR_Filter_out1  -- sfix54_En4
              );

  u_predictor : predictor
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              variable_rsvd => std_logic_vector(Delay3_out1),  -- sfix32_En8
              trigger => trigger_2,
              mu => s_ene_mu,  -- sfix42_En12
              sigma => s_ene_sig,  -- sfix42_En12
              scale => scale,  -- sfix42_En12
              beta => s_ene_beta,  -- sfix42_En12
              predicted => after_beta  -- sfix32_En12
              );

  u_predictor10 : predictor10
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              variable_rsvd => std_logic_vector(Delay5_out1),  -- sfix38_En8
              trigger => trigger_2,
              mu => ene_mu_D2,  -- sfix42_En12
              sigma => ene_sig_D2,  -- sfix42_En12
              scale => scale,  -- sfix42_En12
              beta => ene_beta_D2,  -- sfix42_En12
              predicted => after_beta_1  -- sfix32_En12
              );

  bias_signed <= signed(bias);

  Constant7_out1 <= '0';

  NOT_out1 <=  NOT enable;

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 511
  HDL_Counter_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      HDL_Counter_out1 <= to_unsigned(16#000#, 9);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        IF NOT_out1 = '1' THEN 
          HDL_Counter_out1 <= to_unsigned(16#000#, 9);
        ELSIF enable = '1' THEN 
          HDL_Counter_out1 <= HDL_Counter_out1 + to_unsigned(16#001#, 9);
        END IF;
      END IF;
    END IF;
  END PROCESS HDL_Counter_process;


  Constant4_out1 <= '1';

  
  trigger <= Constant4_out1 WHEN HDL_Counter_out1 = to_unsigned(16#000#, 9) ELSE
      Constant7_out1;

  
  trigger_1 <= Constant7_out1 WHEN enable = '0' ELSE
      trigger;

  Delay2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay2_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay2_reg(0) <= trigger_1;
        Delay2_reg(1 TO 448) <= Delay2_reg(0 TO 447);
      END IF;
    END IF;
  END PROCESS Delay2_process;

  trigger_2 <= Delay2_reg(448);

  
  trigger_bool <= '1' WHEN trigger_2 /= '0' ELSE
      '0';

  intdelay3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      trigger_delay <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        trigger_delay <= trigger_bool;
      END IF;
    END IF;
  END PROCESS intdelay3_process;


  trigger_delayN <=  NOT trigger_delay;

  trigger_rEdge <= trigger_bool AND trigger_delayN;

  Discrete_Time_Integrator2_reg_iv <= to_signed(0, 32);

  signal_in_signed <= signed(signal_in);

  Delay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay_reg <= (OTHERS => to_signed(16#0000#, 16));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay_reg(0) <= signal_in_signed;
        Delay_reg(1 TO 447) <= Delay_reg(0 TO 446);
      END IF;
    END IF;
  END PROCESS Delay_process;

  signal_rsvd <= Delay_reg(447);

  Product1_out1 <= signal_rsvd * signal_rsvd;

  intdelay2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Product1_out1_dlyBalance <= to_signed(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Product1_out1_dlyBalance <= Product1_out1;
      END IF;
    END IF;
  END PROCESS intdelay2_process;


  
  Discrete_Time_Integrator2_reg_toDel <= Discrete_Time_Integrator2_u_add WHEN trigger_rEdge = '0' ELSE
      Discrete_Time_Integrator2_reg_iv;

  Discrete_Time_Integrator2_reg_lowered_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Discrete_Time_Integrator2_x_reg_out <= to_signed(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Discrete_Time_Integrator2_x_reg_out <= Discrete_Time_Integrator2_reg_toDel;
      END IF;
    END IF;
  END PROCESS Discrete_Time_Integrator2_reg_lowered_process;


  Discrete_Time_Integrator2_u_add <= Discrete_Time_Integrator2_x_reg_out + Product1_out1_dlyBalance;

  Constant3_out1 <= to_unsigned(16#0200#, 16);

  Divide2_output : PROCESS (Constant3_out1, Discrete_Time_Integrator2_u_add)
    VARIABLE div_temp : signed(32 DOWNTO 0);
    VARIABLE cast : signed(32 DOWNTO 0);
    VARIABLE cast_0 : signed(16 DOWNTO 0);
  BEGIN
    div_temp := to_signed(0, 33);
    cast := to_signed(0, 33);
    cast_0 := to_signed(16#00000#, 17);
    IF Constant3_out1 = to_unsigned(16#0000#, 16) THEN 
      IF Discrete_Time_Integrator2_u_add < to_signed(0, 32) THEN 
        energy <= signed'(X"80000000");
      ELSE 
        energy <= to_signed(2147483647, 32);
      END IF;
    ELSE 
      cast := resize(Discrete_Time_Integrator2_u_add, 33);
      cast_0 := signed(resize(Constant3_out1, 17));
      div_temp := cast / cast_0;
      IF (div_temp(32) = '0') AND (div_temp(31) /= '0') THEN 
        energy <= X"7FFFFFFF";
      ELSIF (div_temp(32) = '1') AND (div_temp(31) /= '1') THEN 
        energy <= X"80000000";
      ELSE 
        energy <= div_temp(31 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Divide2_output;


  Delay3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay3_out1 <= to_signed(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay3_out1 <= energy;
      END IF;
    END IF;
  END PROCESS Delay3_process;


  
  trigger_bool_1 <= '1' WHEN trigger_2 /= '0' ELSE
      '0';

  intdelay1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      trigger_delay_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        trigger_delay_1 <= trigger_bool_1;
      END IF;
    END IF;
  END PROCESS intdelay1_process;


  trigger_delayN_1 <=  NOT trigger_delay_1;

  trigger_rEdge_1 <= trigger_bool_1 AND trigger_delayN_1;

  Discrete_Time_Integrator1_reg_iv <= to_signed(0, 38);

  RT2_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      RT2_bypass_reg <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_4_1 = '1' THEN
        RT2_bypass_reg <= enable;
      END IF;
    END IF;
  END PROCESS RT2_bypass_process;

  
  RT2_out1 <= enable WHEN enb_1_4_1 = '1' ELSE
      RT2_bypass_reg;

  
  switch_compare_1 <= '1' WHEN RT2_out1 > '0' ELSE
      '0';

  Constant_out1 <= to_signed(0, 54);

  RT1_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      RT1_bypass_reg <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_2_1 = '1' THEN
        RT1_bypass_reg <= enable;
      END IF;
    END IF;
  END PROCESS RT1_bypass_process;

  
  RT1_out1 <= enable WHEN enb_1_2_1 = '1' ELSE
      RT1_bypass_reg;

  
  switch_compare_1_1 <= '1' WHEN RT1_out1 > '0' ELSE
      '0';

  Constant1_out1 <= to_signed(0, 35);

  db4_scaling1_out1(0) <= to_signed(16#0000#, 16);
  db4_scaling1_out1(1) <= to_signed(16#0000#, 16);
  db4_scaling1_out1(2) <= to_signed(16#0000#, 16);
  db4_scaling1_out1(3) <= to_signed(16#0000#, 16);
  db4_scaling1_out1(4) <= to_signed(16#0000#, 16);
  db4_scaling1_out1(5) <= to_signed(16#0001#, 16);
  db4_scaling1_out1(6) <= to_signed(16#0001#, 16);
  db4_scaling1_out1(7) <= to_signed(16#0000#, 16);

  outputgen1: FOR k IN 0 TO 7 GENERATE
    db4_scaling1_out1_1(k) <= std_logic_vector(db4_scaling1_out1(k));
  END GENERATE;

  Discrete_FIR_Filter3_out1_signed <= signed(Discrete_FIR_Filter3_out1);

  -- Downsample output register
  Downsample3_output_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Downsample3_out1 <= to_signed(0, 35);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_2_0 = '1' THEN
        Downsample3_out1 <= Discrete_FIR_Filter3_out1_signed;
      END IF;
    END IF;
  END PROCESS Downsample3_output_process;


  
  Switch3_out1 <= Constant1_out1 WHEN switch_compare_1_1 = '0' ELSE
      Downsample3_out1;

  db4_wavelet_out1(0) <= to_signed(16#0000#, 16);
  db4_wavelet_out1(1) <= to_signed(16#0001#, 16);
  db4_wavelet_out1(2) <= to_signed(-16#0001#, 16);
  db4_wavelet_out1(3) <= to_signed(16#0000#, 16);
  db4_wavelet_out1(4) <= to_signed(16#0000#, 16);
  db4_wavelet_out1(5) <= to_signed(16#0000#, 16);
  db4_wavelet_out1(6) <= to_signed(16#0000#, 16);
  db4_wavelet_out1(7) <= to_signed(16#0000#, 16);

  outputgen: FOR k IN 0 TO 7 GENERATE
    db4_wavelet_out1_1(k) <= std_logic_vector(db4_wavelet_out1(k));
  END GENERATE;

  Discrete_FIR_Filter_out1_signed <= signed(Discrete_FIR_Filter_out1);

  -- Downsample output register
  Downsample_output_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Downsample_out1 <= to_signed(0, 54);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_4_0 = '1' THEN
        Downsample_out1 <= Discrete_FIR_Filter_out1_signed;
      END IF;
    END IF;
  END PROCESS Downsample_output_process;


  
  Switch_out1 <= Constant_out1 WHEN switch_compare_1 = '0' ELSE
      Downsample_out1;

  delayMatch_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch_reg <= (OTHERS => to_signed(0, 54));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_4_0 = '1' THEN
        delayMatch_reg(0) <= Switch_out1;
        delayMatch_reg(1 TO 107) <= delayMatch_reg(0 TO 106);
      END IF;
    END IF;
  END PROCESS delayMatch_process;

  Switch_out1_1 <= delayMatch_reg(107);

  in_rsvd <= Switch_out1_1(18 DOWNTO 0);

  RT_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      in_rsvd_1 <= to_signed(16#00000#, 19);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_4_0 = '1' THEN
        in_rsvd_1 <= in_rsvd;
      END IF;
    END IF;
  END PROCESS RT_process;


  Product_out1 <= in_rsvd_1 * in_rsvd_1;

  intdelay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Product_out1_dlyBalance <= to_signed(0, 38);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Product_out1_dlyBalance <= Product_out1;
      END IF;
    END IF;
  END PROCESS intdelay_process;


  
  Discrete_Time_Integrator1_reg_toDel <= Discrete_Time_Integrator1_u_add WHEN trigger_rEdge_1 = '0' ELSE
      Discrete_Time_Integrator1_reg_iv;

  Discrete_Time_Integrator1_reg_lowered_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Discrete_Time_Integrator1_x_reg_out <= to_signed(0, 38);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Discrete_Time_Integrator1_x_reg_out <= Discrete_Time_Integrator1_reg_toDel;
      END IF;
    END IF;
  END PROCESS Discrete_Time_Integrator1_reg_lowered_process;


  Discrete_Time_Integrator1_u_add <= Discrete_Time_Integrator1_x_reg_out + Product_out1_dlyBalance;

  Constant2_out1 <= to_unsigned(16#0200#, 16);

  Divide1_output : PROCESS (Constant2_out1, Discrete_Time_Integrator1_u_add)
    VARIABLE div_temp1 : signed(38 DOWNTO 0);
    VARIABLE cast1 : signed(38 DOWNTO 0);
    VARIABLE cast_01 : signed(16 DOWNTO 0);
  BEGIN
    div_temp1 := to_signed(0, 39);
    cast1 := to_signed(0, 39);
    cast_01 := to_signed(16#00000#, 17);
    IF Constant2_out1 = to_unsigned(16#0000#, 16) THEN 
      IF Discrete_Time_Integrator1_u_add < to_signed(0, 38) THEN 
        energy_1 <= signed'("10000000000000000000000000000000000000");
      ELSE 
        energy_1 <= signed'("01111111111111111111111111111111111111");
      END IF;
    ELSE 
      cast1 := resize(Discrete_Time_Integrator1_u_add, 39);
      cast_01 := signed(resize(Constant2_out1, 17));
      div_temp1 := cast1 / cast_01;
      IF (div_temp1(38) = '0') AND (div_temp1(37) /= '0') THEN 
        energy_1 <= "01111111111111111111111111111111111111";
      ELSIF (div_temp1(38) = '1') AND (div_temp1(37) /= '1') THEN 
        energy_1 <= "10000000000000000000000000000000000000";
      ELSE 
        energy_1 <= div_temp1(37 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS Divide1_output;


  Delay5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay5_out1 <= to_signed(0, 38);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay5_out1 <= energy_1;
      END IF;
    END IF;
  END PROCESS Delay5_process;


  delayMatch1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      bias_1 <= to_signed(0, 42);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        bias_1 <= bias_signed;
      END IF;
    END IF;
  END PROCESS delayMatch1_process;


  after_beta_signed <= signed(after_beta);

  Add_stage2_add_cast <= resize(bias_1, 43);
  Add_stage2_add_cast_1 <= resize(after_beta_signed, 43);
  Add_op_stage1 <= Add_stage2_add_cast + Add_stage2_add_cast_1;

  after_beta_signed_1 <= signed(after_beta_1);

  Add_stage3_add_cast <= resize(after_beta_signed_1, 43);
  predictor_1 <= Add_op_stage1 + Add_stage3_add_cast;

  svm_out <= std_logic_vector(predictor_1);

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 2
  HDL_Counter1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      HDL_Counter1_out1 <= to_unsigned(16#0#, 4);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        IF NOT_out1 = '1' THEN 
          HDL_Counter1_out1 <= to_unsigned(16#0#, 4);
        ELSIF trigger_2 = '1' THEN 
          IF HDL_Counter1_out1 >= to_unsigned(16#2#, 4) THEN 
            HDL_Counter1_out1 <= to_unsigned(16#0#, 4);
          ELSE 
            HDL_Counter1_out1 <= HDL_Counter1_out1 + to_unsigned(16#1#, 4);
          END IF;
        END IF;
      END IF;
    END IF;
  END PROCESS HDL_Counter1_process;


  
  switch_compare_1_2 <= '1' WHEN HDL_Counter1_out1 >= to_unsigned(16#2#, 4) ELSE
      '0';

  Constant5_out1 <= '0';

  Constant6_out1 <= '1';

  
  done_1 <= Constant5_out1 WHEN switch_compare_1_2 = '0' ELSE
      Constant6_out1;

  delayMatch2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      done <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        done <= done_1;
      END IF;
    END IF;
  END PROCESS delayMatch2_process;


  ce_out <= enb_1_1_1;

END rtl;

